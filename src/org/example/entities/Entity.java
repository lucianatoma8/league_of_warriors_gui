package org.example.entities;

import org.example.gui.MessageUtils;

import java.util.ArrayList;
import java.util.List;

public abstract class Entity implements Battle, Element<Entity> {
    private int currentHealth;
    private int maxHealth;
    private int currentMana;
    private int maxMana;

    private final boolean immuneToFire;
    private final boolean immuneToIce;
    private final boolean immuneToEarth;

    private final List<Spell> abilities;
    private final boolean isPlayer;

    public Entity(int maxHealth, int maxMana, boolean immuneToFire, boolean immuneToIce, boolean immuneToEarth, boolean isPlayer) {
        this.maxHealth = maxHealth;
        this.currentHealth = maxHealth;
        this.maxMana = maxMana;
        this.currentMana = maxMana;
        this.immuneToFire = immuneToFire;
        this.immuneToIce = immuneToIce;
        this.immuneToEarth = immuneToEarth;
        this.abilities = new ArrayList<>();
        this.isPlayer = isPlayer;
    }

    // accept method for visitor pattern
    @Override
    public void accept(Visitor<Entity> visitor) {
        visitor.visit(this);
    }

    public int getCurrentHealth() {
        return currentHealth;
    }

    public int getMaxHealth() {
        return maxHealth;
    }

    public int getCurrentMana() {
        return currentMana;
    }

    public int getMaxMana() {
        return maxMana;
    }

    public void setMaxHealth(int health) {
        this.maxHealth = health;
    }

    public void setMaxMana(int mana) {
        this.maxMana = mana;
    }

    public List<Spell> getAbilities() {
        return abilities;
    }

    public void addAbility(Spell ability) {
        abilities.add(ability);
    }

    public boolean isImmuneToFire() {
        return immuneToFire;
    }

    public boolean isImmuneToIce() {
        return immuneToIce;
    }

    public boolean isImmuneToEarth() {
        return immuneToEarth;
    }

    public void regenerateHealth(int amount) {
        currentHealth = Math.min(maxHealth, currentHealth + amount);
//        System.out.println("Health regenerated by " + amount + ". Current health: " + currentHealth);
    }

    public void regenerateMana(int amount) {
        currentMana = Math.min(maxMana, currentMana + amount);
//        System.out.println("Mana regenerated by " + amount + ". Current mana: " + currentMana);
    }

    public void useAbility(Spell ability, Entity target) {
        if (!abilities.contains(ability)) {
//            System.out.println("Ability not found!");
            MessageUtils.showMessage("Ability not found!", "Error");
            return;
        }

        if (currentMana < ability.getManaCost()) {
//            System.out.println("Not enough mana to use ability: " + ability.getSpellType() + " spell!");
            MessageUtils.showMessage("Not enough mana to use ability: " + ability.getSpellType() + " spell!", "Error");
            return;
        }

        currentMana -= ability.getManaCost();

        // apply the spell as a visitor to the target
        target.accept(ability);

//        boolean isImmune = switch (ability.getSpellType()) {
//            case "Fire" -> target.isImmuneToFire();
//            case "Ice" -> target.isImmuneToIce();
//            case "Earth" -> target.isImmuneToEarth();
//            default -> false;
//        };
//
//        if (isImmune) {
//            System.out.println("Target is immune to " + ability.getSpellType() + "!");
//            return;
//        }
//
//        target.receiveDamage(ability.getDamage());
    }

    public boolean isPlayer() {
        return false;
    }

    public void setCurrentMana(int mana) {
        if (mana < 0) {
            this.currentMana = 0;
        } else if (mana > maxMana) {
            this.currentMana = maxMana;
        } else {
            this.currentMana = mana;
        }
    }

    public void setCurrentHealth(int health) {
        if (health < 0) {
            this.currentHealth = 0;
        } else if (health > maxHealth) {
            this.currentHealth = maxHealth;
        } else {
            this.currentHealth = health;
        }
    }

    @Override
    public void receiveDamage(int damage) {
        currentHealth = Math.max(0, currentHealth - damage);
        if (this instanceof Enemy) {
//            System.out.println("Enemy received " + damage + " damage. Enemy's health: " + currentHealth);
            MessageUtils.showMessage("Enemy received " + damage + " damage. Enemy's health: " + currentHealth, "Enemy");
        } else {
//            System.out.println("Received " + damage + " damage. Current health: " + currentHealth);
            MessageUtils.showMessage("Received " + damage + " damage. Current health: " + currentHealth, "Player");
        }

    }

    @Override
    public int getDamage() {
        // random damage between 10 and 20
        return 10 + (int) (Math.random() * 10);
    }

    public int getDamage(Spell ability) {
       if (ability == null) {
           return getDamage();
       }

       if (currentMana < ability.getManaCost()) {
//           System.out.println("Not enough mana to use ability: " + ability.getSpellType() + " spell!");
              MessageUtils.showMessage("Not enough mana to use ability: " + ability.getSpellType() + " spell!", "Error");
           return getDamage();
       }

       currentMana -= ability.getManaCost();

       return ability.getDamage();
    }

    @Override
    public String toString() {
        return "Entity{" +
                "abilities=" + abilities +
                ", currentHealth=" + currentHealth +
                ", maxHealth=" + maxHealth +
                ", currentMana=" + currentMana +
                ", maxMana=" + maxMana +
                ", immuneToFire=" + immuneToFire +
                ", immuneToIce=" + immuneToIce +
                ", immuneToEarth=" + immuneToEarth +
                '}';
    }
}
